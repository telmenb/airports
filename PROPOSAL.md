# Project Proposal
## Leading Question
The two main questions we want to answer in this project are “what is the shortest flight path between two airports?” and “what is a sequence of airports we can visit, which will start and finish in the same place?” We want to develop a general search tool where the user can input two airports, and the output will display the shortest path between them (least amount of airports to visit), or if the user inputs one airport, we can print all the possible routes that end back at the initial departure. We will use a graph with all of the nodes representing airports. We will use Dijkstra’s algorithm, which uses BFS, to find the shortest path between two nodes. We will also use a cycle detection algorithm to detect cycles in the graph, which we will use to create our round trip calculator.

## Data Acquisition and Processing
### Data Format:
The source of our data will be from OpenFlights. This is a publicly accessible dataset. They provide actual routes between two airports and data of the airport itself. In the routes data, they provide the following: Airline	2-letter, Airline ID, Source airport 3-letter, Source airport ID, Destination airport, Destination airport ID, Codeshare, Stops, Equipment. We will bring in all this data, but we will likely only use the airport 3-letters, the airport IDs, and the stops. The airport data contains airport id, name, city, country, iata, icao, latitude, longitude, altitude timezone, dst, tz, type, source. We will be using the Airport 3-letter (IATA), longitude, and latitude. This data is in CSV format, so we will be able to take only the data we need when parsing through it.
### Data Correction:
Because the data is in CSV format and we know the order of the values, we can parse through the data looking for commas and checking each value that we want. To check for missing data, we can see if there are double commas at any point. In the dataset, there are double commas as some “codeshare” data is empty. We can skip this by checking for the case if it is the 7th value that is missing (codeshare is the 7th value in each set). In the routes, if anything is missing other than the 3-letter, id, or stops data, we will disregard it as we are not using that data anyway. Otherwise, we can find the 3-letter id for the airport online or in their airport data. We can also find the airport ID using their airport dataset. If it is missing in both sets, we can simply set our own ID.
### Data Storage:
For our dataset, we are going to be using a graph data structure. The graph will have an initial root, which we will set as the departure point. Each node will be an airport. All its neighbors will be set using the route dataset. If there are zero stops between the two airports, there will be an edge connecting the airports. The edges represent a flight path, so the amount of edges between two nodes is the number of flights needed to get between them. Each node contains the airport 3-letter, longitude, latitude, and the pointers to its neighbors. Our big O estimate is O(n) where n is the number of airports. We have as many nodes as we have airports.

## Graph Algorithms
### Constructing Our Graph:
First, we have to create the graph itself. We will start by creating airpot node objects from the airport dataset stream on the heap and storing pointers to those objects in a vector. Then, we look at the route information. We will parse through those line by line as well, checking for the two airport 3-letters (departure and destination). We then traverse through our airport vector looking for those two airports. Once they have been found, we add to the departure airport’s neighbors vector the address of the destination airport object. This will run in O(n*m) where n is the number of airports and m is the number of flights. This function does not have an output. It simply stores the graph data in memory.
### Dijkstra's Algorithm:
At this point, our graph will have been constructed, so our data does not need to be adjusted. For inputs, the algorithm takes in two airport nodes, the departure, and the destination. We will output a vector containing the indices of the neighbors visited in each airport. For example, we visit three airports. We look at the departure neighbor vector at the first index of the returned vector, then we look at the departure neighbor vector at the second index of the returned vector. This gives us the path. This will run in O(nlogn) where n is the number of airports.
### Cycle Detection:
Our goal is to find all cycles that start and end at our departure airport. That way, a person who hasn’t decided where they wish to travel to, can look through and weigh their options for a round-trip of a lifetime. Using DFS and graph-coloring, we traverse through the graph until we find our initial node. Each path will be storing a vector of indices in adjacency lists, and all paths will be compiled into a vector, therefore creating a vector of vectors. The expected runtime will be O(n+m) where n is the number of airports and m is the number of flights in the graph.

## Timeline
Data acquisition has already been achieved at the time of writing. Data processing is anticipated to take one week; this should include parsing input to sanitize data and remove unnecessary parameters. We already have a rough outline of the design structure, so we are not anticipating it would take more than a week to finalize. The above-mentioned two can be developed simultaneously. The graph structure constructor is expected to be completed by week 3, and the rest of the development time is allocated for the graphing algorithms. Ideally, we would like to have Dijkstra’s algorithm fully implemented and tested by the mid-project check-in.